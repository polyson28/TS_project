# -*- coding: utf-8 -*-
"""feature_selection1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YUbMNXqJIeWZfMu0B2CM07wXFxaOYZHR
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.linear_model import LassoCV, RidgeCV, ElasticNetCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import TimeSeriesSplit, cross_val_score
from sklearn.feature_selection import RFECV, SequentialFeatureSelector
from tqdm import tqdm
import sys
sys.path.append('../')

from TS_model.feature_engeneering import FeatureEngineer
from TS_model.feature_selection import WrapperMethod, StabilityAnalysis, DefaultMethod, FilterMethod

# %load_ext autoreload
# %autoreload 2

"""# Выгрузка изначальных данных & Feature engeneering"""

tax_dates_dict = {
    "2017-01-25": ["НДФЛ", "НДС"],
    "2017-02-15": ["Страховые взносы"],
    "2017-04-28": ["НДФЛ", "НДС"],
    "2017-05-01": ["Акцизы"],
    "2017-10-10": ["Налог на имущество организаций"],
    "2018-01-25": ["НДФЛ", "НДС"],
    "2018-02-15": ["Налог на землю"],
    "2019-04-25": ["НДС"],
    "2019-07-01": ["Транспортный налог"],
    "2020-07-15": ["НДФЛ"],
    "2021-03-15": ["НДФЛ", "Страховые взносы", "Налог на прибыль"],
}


tax_dates = list(tax_dates_dict.keys())

import pandas as pd
tax_dates = pd.to_datetime(tax_dates)
 feature_extactor = FeatureEngineer(data)

data = pd.read_csv('/content/final.csv', parse_dates=['date'])
data.columns = data.columns.str.lower()

macro_cols = [
    'digitalization_level', 'age_0_14', 'age_15_64', 'age_65_plus',
    'population_density', 'consumer_confidence_index', 'gdp_per_capita',
    'unemployment_rate', 'trade_balance', 'inflation_rate', 'imoex', 'usd_rate'
]
macro_df = data.set_index('date')[macro_cols]

print(data.columns)
macro_df

feature_extactor = FeatureEngineer(data, date_col='date')

feature_extactor = (
    feature_extactor.add_lag_features(lags=[1, 2, 7])
      .add_rolling_features(windows=[3, 7, 30])
      .add_seasonal_features()
      .add_macro_features(macro_df)
)


feature_extactor = feature_extactor.add_special_dates(tax_dates)

X, y = feature_extactor.get_feature_df()

"""# Feature selection

## Встроенные методы
"""

default = DefaultMethod()
default.fit(features, target)

lasso = LassoCV(cv=tscv, max_iter=10000, random_state=42)
print(default.implement(lasso))
default.vizualize()

default = DefaultMethod()
default.fit(features, target)

random_forest = RandomForestRegressor(n_estimators=500, random_state=42)
print(default.implement(random_forest))
default.vizualize()

"""## Оберточные методы"""

models_for_wrapper = {
    'lasso': LassoCV(cv=tscv, max_iter=10000, random_state=42),
    'elastic_net': ElasticNetCV(cv=tscv, max_iter=10000, random_state=42),
    'random_forest': RandomForestRegressor(n_estimators=100, random_state=42)
}

wrapper = WrapperMethod()
wrapper.fit(features, target)

for name, model in models_for_wrapper.items():
    res = wrapper.implement(model, tscv)
    print(f'Отобранные признаки на основе {name}: {res}', end='\n')

    wrapper.vizualize(f'Ranking по RFECV на основе {name}')

"""## Фильтрационные методы"""

filter = FilterMethod()
filter.fit(features, target)

print(filter.implement(k=5))
filter.vizualize('Важность признаков по трансфертной энтропии')

"""# Оценка стабильности"""

method_params = {
    'default': {
        'Lasso': {'model': LassoCV(cv=tscv, max_iter=10000, random_state=42)},
        'RandomForest': {'model': RandomForestRegressor(n_estimators=500, random_state=42)}
    },
    'wrapper': {
        # 'Lasso': {'model': LassoCV(cv=tscv, max_iter=10000, random_state=42), 'tscv': tscv},
        # 'ElasticNet': {'model': ElasticNetCV(cv=tscv, max_iter=10000, random_state=42), 'tscv': tscv},
        'RandomForest': {'model': RandomForestRegressor(n_estimators=100, random_state=42), 'tscv': tscv}
    },
    'filter': {
        'TransferEntropy': {'k': 5}
    }
}

methods = []
method_configs = []
stabilities = []

stability_eval = StabilityAnalysis()
stability_eval.fit(features, target)

for method, params in tqdm(method_params.items()):
    for method_config, param in params.items():
        stability_eval.collect_binary(n_splits=5, method=method, **param)
        method_stability = stability_eval.implement()

        methods.append(method)
        method_configs.append(method_config)
        stabilities.append(method_stability)

pd.DataFrame(
    {
        'method': methods,
        'method_config': method_configs,
        'stability': stabilities
    }
)

